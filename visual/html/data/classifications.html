<!-- extend from site layout -->
{% extends "templates/site.html" %}

{% block title %}{{ title }}{% endblock %}

{% block body %}
<div class="grid5col1">
  
  <h2>{{ title }}</h2>
  
  <div id="attr_toggle">
    <input type="radio" name="attr" value="hs" onclick="window.location='{{ url_for('data.classifications', attr='hs') }}all/'" {% if page_attr == "hs" %}checked{% endif %}>
    <label for="hs">Products</label>
    
    <input type="radio" name="attr" value="cbo" onclick="window.location='{{ url_for('data.classifications', attr='cbo') }}all/'" {% if page_attr == "cbo" %}checked{% endif %}>
    <label for="cbo">Occupations</label>
    
    <input type="radio" name="attr" value="isic" onclick="window.location='{{ url_for('data.classifications', attr='isic') }}all/'" {% if page_attr == "isic" %}checked{% endif %}>
    <label for="isic">Industries</label>
    
    <input type="radio" name="attr" value="bra" onclick="window.location='{{ url_for('data.classifications', attr='bra') }}all/'" {% if page_attr == "bra" %}checked{% endif %}>
    <label for="bra">Brazilian Locations</label>
    
    <input type="radio" name="attr" value="wld" onclick="window.location='{{ url_for('data.classifications', attr='wld') }}all/'" {% if page_attr == "wld" %}checked{% endif %}>
    <label for="wld">Countries</label>
  </div>
  
  <div class="data-dropdown">
    <select id="category" onchange="update_depth(this.options[this.selectedIndex].value);">
      <option value="all">All</option>
      {% for cat_digit, cat_name in category_lookup.iteritems() %}
      <option value="{{ cat_name }}" {% if cat_name == category %}selected="selected"{% endif %}>{{ cat_name }}</option>
      {% endfor %}
    </select>
  </div>
  
</div>
<div class="grid5col4">

  <div id="results">
    <table>
      <thead>
        <tr>
          <th></th>
          <th>ID</th>
          <th>Category</th>
          <th>Name (English)</th>
          <th>Name (Portuguese)</th>
        </tr>
      </thead>
      <tbody>
        <!-- {% for attr in attrs %}
        <tr>
          <td class="icon">
            <div style="background-color: {{ attr.color }}" title="{{ attr.id }}"></div>
          </td>
          <td>{{ attr.id }}</td>
          <td><script>document.write(format_name("{{ page_attr }}_{{ attr.id|length }}", "{{ g.locale }}"))</script></td>
          <td>{{ attr.name_en }}</td>
          <td>{{ attr.name_pt }}</td>
        </tr>
        {% endfor %} -->
      </tbody>
    </table>
  </div>
  
  
</div>

<script src="/static/js/utils/utils.infinite_scroll.js"></script>
<script>
// dropdown for changing number of items per page
function update_per_page(per_page){
  window.location = "{{ url_for('data.classifications', attr=page_attr, category=category) }}?per_page=" + per_page;
}

// dropdown for changing the category
d3.select("#category").on("change", function(){
  var new_page_url = "{{ url_for('data.classifications', attr=page_attr) }}all/";
  new_page_url = new_page_url.replace("all", this.value)
  window.location = new_page_url
})
function update_depth(depth){
  // window.location = "{{ url_for('data.classifications', attr=page_attr, category=category) }}?per_page=" + per_page;
  var new_page_url = "{{ url_for('data.classifications', attr=page_attr) }}all/";
  new_page_url = new_page_url.replace("all", depth)
  window.location = new_page_url
}

// d3.selectAll("td.icon > div").style("background-image", function(){
//   return "url('"+visual.icon(this.title, "{{ page_attr }}") + "')"
// })

// The meat and potatoes, this function get called after we've made the call
// to the server
function display(error, data) {
  
  // clean up data into one nice array of activities
  attrs = data.attrs.map(function(d){
    d["category"] = data.category_lookup[d.id.length]
    return d
  });
  
  // we're obviously no longer fetching
  fetching = false;
  
  // if the server returned an empty list, return and get rid of loading div
  if (!attrs.length) {
    if(offset == 0){
      // no attrs message
    }
    offset = NaN;
    d3.select(".loading").remove();
    return;
  }
  
  // increment offset by number of items received from server
  offset += attrs.length;
  
  // using d3's helpful enter/update/exit paradigm add new items from server
  x = 1
  var attrs_enter = d3.select("table > tbody").selectAll("tr")
    .data(attrs, function(d){ x++; return d ? d.id : x })
    .enter().append("tr")

  
  attrs_enter.append("td")
    .attr("class", "icon")
    .append("div")
      .style("background-image", function(d){
        return "url('"+visual.icon(d.id, data.attr_type) + "')"
      })
      .style("background-color", function(d){ return d.color })
      .attr("title", function(d){ return d.id; })

  attrs_enter.append("td").text(function(d){ return d.id; })
  attrs_enter.append("td").text(function(d){ return d.category; })
  attrs_enter.append("td").text(function(d){ return d.name_en; })
  attrs_enter.append("td").text(function(d){ return d.name_pt; })
  
  
  return
  
  // the title div housing the icon and title
  var title_div = activities_enter.append("div")
      .attr("class", "feed_title")
  
  // add icon
  title_div.append("img")
      .attr("src", function(d){
        var img_url = "/static/img/icons/tiles/";
        
        // if this is a starred app, we need to figure out which app it is
        // and use this app's icon
        if(d.activity_type == "starred"){
          var app_type = d.app_id.split("/")[0]
          img_url += app_type+"_tile.png";
        }
        
        // otherwise it's an ask sabrina question/reply
        else {
          img_url += "ask_sabrina_tile.png";
        }
        return img_url
      })
      .attr("width", "23px")
      .attr("padding-bottom", "23px")
  
  // the title (strip out HTML!)
  title_div.append("p")
    .html(function(d){
      return d.title.replace(/(<([^>]+)>)/ig,"");
    })
  
  // lastly, the div that holds the data
  activities_enter.append("div")
      .attr("class", "feed_date")
      .text(function(d) { return formatDate(d.timestamp); });
  
  // maybe the user has a super dooper tall screen (or high resolution)
  // so we need to check if we're already at the bottem, even though we
  // just added new items
  setTimeout(maybe_fetch, 50);
}

function item_formatter(container_el, dataset){
  
  var tbody = d3.select(container_el).select("tbody")
  // create a row for each object in the data
  var x = 1;
  var rows = tbody.selectAll("tr").data(dataset, function(d){ x++; return d ? d.id : x })
  var rows_enter = rows.enter().append("tr");
  // 
  // // create cells for each datum
  // var cells = rows.selectAll("td").data(function(row){
  //     return ordered_columns.map(function(column) {
  //       return {"column": column, "value": row[column]};
  //     });
  // })
  // 
  // cells.enter().append("td").style("padding", "2px 5px")
  // rows.selectAll("td").text(function(d) { return d.value; });

  rows_enter.append("td")
    .attr("class", "icon")
    .append("div")
      .style("background-image", function(d){
        return "url('"+visual.icon(d.id, d.attr_type) + "')"
      })
      .style("background-color", function(d){ return d.color })
      .attr("title", function(d){ return d.id; })

  rows_enter.append("td").text(function(d){ return d.id; })
  rows_enter.append("td").text(function(d){ return d.category; })
  rows_enter.append("td").text(function(d){ return d.name_en; })
  rows_enter.append("td").text(function(d){ return d.name_pt; })
  

}




var is = infinite_scroll().format_items(item_formatter);
d3.select("#results")
  .call(is)


</script>

{% endblock %}